# DDD開発での仕様の決め方 - LLMOpsプロジェクトを例に

## 学習計画とチェックリスト

このガイドでは、実際のLLMOpsプロジェクトを題材に、DDD（ドメイン駆動設計）での仕様決定プロセスを段階的に学びます。

### 学習の進捗チェックリスト

- [ ] **Step 1**: ドメインの探索と理解（ユビキタス言語の確立）
- [ ] **Step 2**: 境界づけられたコンテキストの識別
- [ ] **Step 3**: エンティティと値オブジェクトの識別
- [ ] **Step 4**: 集約の設計
- [ ] **Step 5**: ドメインサービスの抽出
- [ ] **Step 6**: リポジトリの設計
- [ ] **Step 7**: アプリケーションサービスの設計
- [ ] **Step 8**: 実装への落とし込み

---

## Step 1: ドメインの探索と理解（ユビキタス言語の確立）

### 目的
ビジネスの専門家と開発者が同じ言葉で会話できるようにする。

### LLMOpsプロジェクトでの実践

#### 1.1 ステークホルダーとの会話から重要な概念を抽出

実際の会話例：
```
ビジネス側：「請求書のOCR結果からGeminiで情報を抽出して、その精度を検証したい」
開発側：「つまり、文書から構造化データを抽出して、正解データと比較するんですね」
```

#### 1.2 用語の統一（ユビキタス言語）

| ビジネス用語 | 統一した用語 | 定義 |
|------------|------------|------|
| 精度検証 | Accuracy Evaluation | 抽出結果と正解データを比較して精度を算出すること |
| 実験 | Experiment | 特定の設定で精度検証を実行すること |
| 抽出結果 | Extraction Result | LLMが文書から抽出した構造化データ |
| プロンプト | Prompt Template | LLMへの指示文のテンプレート |

#### 1.3 重要な動詞の識別

- **抽出する** (Extract): OCR結果から構造化データを取り出す
- **評価する** (Evaluate): 抽出結果の精度を計算する
- **実験する** (Experiment): 複数の手法を試して比較する

### 演習問題
あなたのプロジェクトで、ビジネス側と開発側で異なる用語を使っている例を3つ挙げて、統一してみましょう。

---

## Step 2: 境界づけられたコンテキストの識別

### 目的
システムを適切な境界で分割し、各コンテキスト内で一貫したモデルを保つ。

### LLMOpsプロジェクトでの実践

#### 2.1 コンテキストの候補を洗い出す

```
初期の候補：
- 文書処理コンテキスト（OCR、PDF処理）
- 抽出コンテキスト（LLMによるデータ抽出）
- 精度評価コンテキスト（精度計算、実験管理）
- プロンプト管理コンテキスト（プロンプトのバージョン管理）
```

#### 2.2 境界を決定する基準

1. **言語の一貫性**: 同じ用語が同じ意味で使われるか
2. **変更の頻度**: 一緒に変更されることが多いか
3. **チームの境界**: 誰が責任を持つか

#### 2.3 最終的な境界

```
今回のスコープ：
┌─────────────────────────────────────┐
│  LLM精度検証コンテキスト              │
│  - Extraction（抽出）                │
│  - Experiment（実験）                │
│  - Accuracy Evaluation（精度評価）   │
└─────────────────────────────────────┘
         ↓ API連携
┌─────────────────────────────────────┐
│  既存Railsシステム（別コンテキスト）    │
│  - PDF処理                          │
│  - OCR処理                          │
└─────────────────────────────────────┘
```

### 演習問題
あなたのシステムで、異なるコンテキストに分けるべき機能群を識別してみましょう。

---

## Step 3: エンティティと値オブジェクトの識別

### 目的
ドメインモデルの基本要素を適切に分類する。

### LLMOpsプロジェクトでの実践

#### 3.1 エンティティの識別基準

**質問リスト**：
1. 一意に識別する必要があるか？
2. ライフサイクル（状態遷移）があるか？
3. 「どの○○」という質問に答える必要があるか？

**Experimentをエンティティと判断した過程**：
```
Q1: 一意に識別する必要があるか？
A1: はい。「実験ID: exp_20240115_v1の結果を見たい」

Q2: ライフサイクルがあるか？
A2: はい。pending → running → completed

Q3: 「どの実験」という質問に答える必要があるか？
A3: はい。「どの実験が最も精度が高かったか」

結論 → エンティティ
```

#### 3.2 値オブジェクトの識別基準

**質問リスト**：
1. 値そのものが重要か？
2. 不変（イミュータブル）か？
3. 交換可能か？

**AccuracyMetricを値オブジェクトと判断した過程**：
```
Q1: 値そのものが重要か？
A1: はい。「精度92.5%」という値が重要

Q2: 不変か？
A2: はい。一度計算したら変更しない

Q3: 交換可能か？
A3: はい。新しい計算結果で置き換え可能

結論 → 値オブジェクト
```

#### 3.3 判断に迷った例

**ExtractionResult の判断過程**：
```
初期の迷い：「抽出結果に名前をつけるか？」

議論：
- 案1: 値オブジェクト（単なる抽出データ）
- 案2: エンティティ（追跡可能な結果）

決定理由：
- 「document_id: doc_001の抽出結果」として参照される
- 複数バージョンの抽出結果を比較する
→ エンティティとして扱う
```

### 演習問題
以下の概念をエンティティか値オブジェクトか判断してください：
1. ユーザーのメールアドレス
2. 注文
3. 商品の価格
4. 配送先住所

---

## Step 4: 集約の設計

### 目的
関連するエンティティと値オブジェクトをグループ化し、一貫性の境界を定める。

### LLMOpsプロジェクトでの実践

#### 4.1 集約の識別

**Experiment集約**：
```
Experiment（集約ルート）
├── ExperimentConfig（値オブジェクト）
├── DocumentResult[]（値オブジェクト）
└── ExperimentSummary（値オブジェクト）
```

#### 4.2 集約境界の決定理由

1. **トランザクション境界**：
   - 実験の状態更新と結果の記録は同時に行う
   - 個別のドキュメント結果は独立して更新可能

2. **一貫性の要求**：
   ```
   不変条件：
   - successful_count + failed_count = total_documents
   - 実験が完了なら全ドキュメントが処理済み
   ```

3. **同時実行の考慮**：
   - 複数の実験は並行実行可能
   - 同一実験内の更新は制御が必要

#### 4.3 集約設計の注意点

**大きすぎる集約を避ける**：
```
❌ 悪い例：
Experiment
├── ExtractionResult[] （数千件のデータ）
└── すべての履歴データ

✅ 良い例：
Experiment
├── DocumentResult[]（サマリー情報のみ）
└── 詳細はIDで参照
```

### 演習問題
ECサイトの「注文」を集約ルートとした場合、どこまでを集約に含めるべきか設計してみましょう。

---

## Step 5: ドメインサービスの抽出

### 目的
エンティティや値オブジェクトに属さないビジネスロジックを適切に配置する。

### LLMOpsプロジェクトでの実践

#### 5.1 ドメインサービスが必要な場面

**AccuracyEvaluationServiceを作った理由**：

1. **複数のオブジェクトにまたがる処理**：
   ```python
   # 実際の抽出結果と期待値を比較
   # どちらのオブジェクトのメソッドにすべきか不明確
   actual: ExtractionResult
   expected: ExtractionResult
   weights: FieldWeights
   
   # → サービスとして独立させる
   accuracy = evaluation_service.evaluate(actual, expected, weights)
   ```

2. **ドメインの重要な概念**：
   - 「精度評価」は業務上の重要な処理
   - 複雑なアルゴリズムを含む
   - 将来的に評価方法が変わる可能性

#### 5.2 サービス設計のガイドライン

```
良いドメインサービス：
✅ ステートレス（状態を持たない）
✅ ドメインの言葉で表現される
✅ ビジネスロジックを含む

悪い例：
❌ データアクセスのみ（→リポジトリ）
❌ 技術的な処理のみ（→インフラ層）
❌ 単純な計算のみ（→値オブジェクトのメソッド）
```

### 演習問題
「在庫から商品を引き当てる」処理は、どこに実装すべきか考えてみましょう。

---

## Step 6: リポジトリの設計

### 目的
ドメインオブジェクトの永続化を抽象化し、ドメイン層を技術的詳細から分離する。

### LLMOpsプロジェクトでの実践

#### 6.1 リポジトリインターフェースの設計

```python
# ドメイン層で定義（抽象）
class ExperimentRepository(ABC):
    @abstractmethod
    def save(self, experiment: Experiment) -> None:
        """実験を保存する"""
        
    @abstractmethod
    def find_by_id(self, experiment_id: str) -> Optional[Experiment]:
        """IDで実験を取得"""
        
    @abstractmethod
    def find_recent(self, limit: int) -> List[Experiment]:
        """最近の実験を取得"""
```

#### 6.2 設計の意図

1. **集約単位でのアクセス**：
   - Experimentは集約全体を読み書き
   - 部分的な更新は避ける

2. **ドメインに必要なメソッドのみ**：
   ```python
   # ✅ ビジネスで必要
   find_by_dataset(dataset_name: str)
   
   # ❌ 技術的すぎる
   execute_sql(query: str)
   ```

3. **検索条件の表現**：
   ```python
   # Specificationパターンの使用
   class ExperimentSpecification:
       def __init__(self, status: str, date_range: DateRange):
           self.status = status
           self.date_range = date_range
   ```

### 演習問題
「特定期間の売上上位商品を取得する」機能のリポジトリメソッドを設計してください。

---

## Step 7: アプリケーションサービスの設計

### 目的
ユースケースを実装し、ドメイン層のオブジェクトを協調させる。

### LLMOpsプロジェクトでの実践

#### 7.1 ユースケースの識別

```
アクターとゴール：
- 開発者が「実験を実行して精度を確認したい」
- システム管理者が「複数の実験結果を比較したい」
- MLエンジニアが「最適なプロンプトを見つけたい」
```

#### 7.2 RunExperimentUseCase の設計過程

```python
class RunExperimentUseCase:
    """実験実行ユースケース"""
    
    def __init__(self,
                 experiment_repo: ExperimentRepository,
                 langfuse_service: LangfuseService,
                 gemini_service: GeminiService,
                 evaluation_service: AccuracyEvaluationService):
        # 依存性注入
        
    def execute(self, config_path: str) -> ExperimentResultDto:
        # 1. 設定を読み込む（インフラ層の責務）
        # 2. 実験を作成する（ドメイン層）
        # 3. データセットを取得する（インフラ層）
        # 4. 各ドキュメントを処理する
        # 5. 精度を評価する（ドメイン層）
        # 6. 結果を保存する（インフラ層経由）
```

#### 7.3 責務の分離

```
アプリケーション層がやること：
✅ ユースケースのフロー制御
✅ トランザクション管理
✅ DTOへの変換

アプリケーション層がやらないこと：
❌ ビジネスルールの実装（→ドメイン層）
❌ 技術的な処理（→インフラ層）
❌ HTTPリクエストの処理（→インターフェース層）
```

### 演習問題
「商品を購入する」ユースケースで、アプリケーション層が調整すべき処理を列挙してください。

---

## Step 8: 実装への落とし込み

### 目的
設計したモデルを実際のコードに変換する。

### LLMOpsプロジェクトでの実践

#### 8.1 パッケージ構造への反映

```
src/
├── domain/                 # ビジネスロジック
│   ├── models/            # エンティティ・値オブジェクト
│   ├── services/          # ドメインサービス
│   └── repositories/      # リポジトリインターフェース
├── application/           # ユースケース
├── infrastructure/        # 技術的実装
└── interfaces/           # 外部インターフェース
```

#### 8.2 依存性注入の設定

```python
# DIコンテナの設定例
def create_run_experiment_use_case() -> RunExperimentUseCase:
    # インフラ層の実装を注入
    config = ConfigurationService()
    langfuse = LangfuseService(config)
    gemini = GeminiService(config)
    repo = FileExperimentRepository(config)
    
    # ドメインサービス
    eval_service = AccuracyEvaluationService()
    
    return RunExperimentUseCase(repo, langfuse, gemini, eval_service)
```

#### 8.3 テスト戦略

```python
# ドメイン層のテスト（単体テスト）
def test_accuracy_calculation():
    service = AccuracyEvaluationService()
    result = service.evaluate(actual, expected, weights)
    assert result.overall_score == 0.92

# アプリケーション層のテスト（統合テスト）
def test_run_experiment_use_case():
    # モックを使用
    mock_repo = Mock(ExperimentRepository)
    use_case = RunExperimentUseCase(mock_repo, ...)
    result = use_case.execute("test.yml")
```

### 演習問題
設計したドメインモデルのテストケースを3つ考えてみましょう。

---

## まとめ：DDD仕様決定のチェックリスト

仕様を決定する際の最終確認：

1. **ユビキタス言語**
   - [ ] ビジネス側と同じ言葉を使っているか
   - [ ] 用語集は作成したか

2. **境界づけられたコンテキスト**
   - [ ] 明確な境界があるか
   - [ ] 他のコンテキストとの関係は定義したか

3. **ドメインモデル**
   - [ ] エンティティと値オブジェクトは適切に分類したか
   - [ ] 集約の境界は適切か
   - [ ] 不変条件は明確か

4. **サービス設計**
   - [ ] ドメインサービスは本当に必要か
   - [ ] アプリケーションサービスの責務は明確か

5. **実装可能性**
   - [ ] 技術的な制約は考慮したか
   - [ ] テスト可能な設計か

## 次のステップ

1. 実際のコードを書いてみる
2. Event Sourcingなどの高度なパターンを学ぶ
3. CQRSなどのアーキテクチャパターンを検討する

質問や議論したいポイントがあれば、具体例を使って深掘りしていきましょう！